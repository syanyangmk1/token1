#include <iostream>
#include <vector>
#include <string>
#include <cstdlib>
#include <ctime>
#include <stack>
#include <cctype>
#include <sstream>
#include <stdexcept>
#include <cmath>

enum class TokenType {
    Operator, Operand
};

struct Token {
    TokenType Type;
    std::string Data; // 데이터는 문자열로 저장
};

// Fraction 클래스: 분수 계산을 위한 클래스
class Fraction {
public:
    int numerator;  // 분자
    int denominator;  // 분모

    // 생성자: 기본적으로 1/1로 초기화
    Fraction(int num = 0, int denom = 1) : numerator(num), denominator(denom) {
        if (denom == 0) throw std::runtime_error("Denominator cannot be zero.");
        reduce();  // 분수의 기약분수로 만드는 과정
    }

    // 분수 출력
    void print() const {
        std::cout << numerator << "/" << denominator;
    }

    // 분수 -> double로 변환
    double toDouble() const {
        return static_cast<double>(numerator) / denominator;
    }

    // 분수 덧셈
    Fraction operator+(const Fraction& other) const {
        int commonDenom = denominator * other.denominator;
        int num = numerator * other.denominator + other.numerator * denominator;
        return Fraction(num, commonDenom);
    }

    // 분수 뺄셈
    Fraction operator-(const Fraction& other) const {
        int commonDenom = denominator * other.denominator;
        int num = numerator * other.denominator - other.numerator * denominator;
        return Fraction(num, commonDenom);
    }

    // 분수 곱셈
    Fraction operator*(const Fraction& other) const {
        return Fraction(numerator * other.numerator, denominator * other.denominator);
    }

    // 분수 나눗셈
    Fraction operator/(const Fraction& other) const {
        if (other.numerator == 0) throw std::runtime_error("Cannot divide by zero.");
        return Fraction(numerator * other.denominator, denominator * other.numerator);
    }

private:
    // 분수를 기약분수로 만드는 함수
    void reduce() {
        int gcd = findGCD(abs(numerator), abs(denominator));
        numerator /= gcd;
        denominator /= gcd;
    }

    // 최대공약수 (GCD) 계산
    int findGCD(int a, int b) const {
        while (b != 0) {
            int temp = b;
            b = a % b;
            a = temp;
        }
        return a;
    }
};

// 연산자 우선순위 반환
int getOperatorPriority(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

// 연산 수행
Fraction applyOperator(const Fraction& left, const Fraction& right, char op) {
    switch (op) {
        case '+': return left + right;
        case '-': return left - right;
        case '*': return left * right;
        case '/': return left / right;
        default: throw std::runtime_error("Invalid operator");
    }
}

// 사용자 입력 수식에서 토큰을 쪼개는 함수
std::vector<Token> tokenize(const std::string& input) {
    std::vector<Token> tokens;
    size_t i = 0;
    while (i < input.size()) {
        char ch = input[i];
        if (std::isspace(ch)) {
            ++i;
            continue;
        }
        if (std::isdigit(ch) || ch == '.') {
            // 숫자 또는 소수점 처리
            size_t start = i;
            while (i < input.size() && (std::isdigit(input[i]) || input[i] == '.' || input[i] == '/')) {
                ++i;
            }
            tokens.push_back({TokenType::Operand, input.substr(start, i - start)});
        } else {
            // 연산자 처리
            tokens.push_back({TokenType::Operator, std::string(1, ch)});
            ++i;
        }
    }
    return tokens;
}

// 토큰을 연결하여 하나의 수식으로 변환하는 함수
std::string joinTokens(const std::vector<Token>& tokens) {
    std::string result;
    for (const auto& token : tokens) {
        result += token.Data + " "; // 각 토큰 데이터를 공백으로 구분하여 추가
    }
    if (!result.empty()) {
        result.pop_back(); // 마지막 공백 제거
    }
    return result;
}

// 중위 표기법 계산 함수
Fraction evaluateExpression(const std::vector<Token>& tokens) {
    std::stack<Fraction> operands;  // 숫자 스택
    std::stack<char> operators;   // 연산자 스택

    for (const auto& token : tokens) {
        if (token.Type == TokenType::Operand) {
            // 토큰이 숫자일 경우 (정수 또는 실수)
            std::string data = token.Data;
            size_t slashPos = data.find('/');
            if (slashPos != std::string::npos) {
                // 분수 처리: a/b 형태의 분수
                int numerator = std::stoi(data.substr(0, slashPos));
                int denominator = std::stoi(data.substr(slashPos + 1));
                operands.push(Fraction(numerator, denominator));
            } else {
                // 정수 또는 실수 처리
                double value = std::stod(data);
                operands.push(Fraction(value * 1000, 1000));  // 소수는 1000분의 1로 처리
            }
        } else if (token.Type == TokenType::Operator) {
            while (!operators.empty() && getOperatorPriority(operators.top()) >= getOperatorPriority(token.Data[0])) {
                // 연산자 우선순위가 더 높은 연산자가 있다면 계산
                Fraction right = operands.top();
                operands.pop();
                Fraction left = operands.top();
                operands.pop();
                char op = operators.top();
                operators.pop();
                operands.push(applyOperator(left, right, op));
            }
            operators.push(token.Data[0]); // 연산자 스택에 푸시
        }
    }

    // 남아있는 연산자들 계산
    while (!operators.empty()) {
        Fraction right = operands.top();
        operands.pop();
        Fraction left = operands.top();
        operands.pop();
        char op = operators.top();
        operators.pop();
        operands.push(applyOperator(left, right, op));
    }

    return operands.top(); // 최종 계산 결과 반환
}

int main() {
    std::string inputExpression;
    
    // 사용자 입력 받기
    std::cout << "Enter an expression (e.g., 3.5 + 2 * 4 / 2 or 3/4 + 1/2): ";
    std::getline(std::cin, inputExpression);

    try {
        // 입력을 단위별로 토큰화
        auto tokens = tokenize(inputExpression);
        
        // 디버깅: 분리된 토큰 출력
        std::cout << "Tokens: ";
        for (const auto& token : tokens) {
            std::cout << token.Data << " ";
        }
        std::cout << std::endl;

        // 계산 수행
        Fraction result = evaluateExpression(tokens);
        std::cout << "Calculated Result: " << result.toDouble() << std::endl;
        
    } catch (const std::exception& ex) {
        std::cerr << "Error: " << ex.what() << std::endl;
    }

    return 0;
}
